#!/usr/bin/env ruby

require 'date'

def query(cmd)
  `#{cmd}`.chomp
end

def command(cmd)
  # quietly executes, but does tell you the exit status
  system("#{cmd} > /dev/null 2>&1")
end

Merge = Struct.new(:branch, :days_till_stale) do
  def conflict?
    diff.size > 0
  end

  def stale?
    last_touched < stale_cutoff_date
  end

  def author
    query("git log -n1 --format='%an <%ae>' #{branch}")
  end

  private

  def stale_cutoff_date
    Date.today - days_till_stale
  end

  def last_touched
    Date.parse(log_date)
  end

  def log_date
    query("git log -1 --date=iso --format=%cd #{branch}")
  end

  def diff
    # you can't dry run a merge, so we have to apply and abort merges
    command("git merge --no-ff --no-commit #{branch}")
    query("git diff").tap do
      command("git merge --abort")
    end
  end
end

MergeRacer = Struct.new(:branch) do
  MAINLINE = "origin/HEAD" # defaultly origin/master
  STALE_THRESHOLD = 4 * 7 # days
  SEPARATOR = "\n"

  def call
    if dirty?
      puts "Cowardly refusing to run, please commit your work or update .gitignore"
      puts "You can figure out what files to modify with\n"
      puts "  git status"
    elsif recent_conflicts.none?
      puts "Congratulations! Your branch doesn't conflict with anyone"
    else
      puts "Danger! Merge race in progress"
      recent_conflicts.each do |merge|
        puts "* Conflict: #{branch} with #{merge.branch}, last authored by #{merge.author}"
      end
    end

    puts SEPARATOR
  end

  def abort
    puts "Abort! Abort!"
    command("git merge --abort")
  end

  private

  def dirty?
    query("git status --porcelain").length > 0
  end

  def recent_conflicts
    @recent_conflicts ||= merges.reject(&:stale?).select(&:conflict?)
  end

  def merges
    branches_from_merge_base.map { |branch| Merge.new(branch, STALE_THRESHOLD) }
  end

  def branches_from_merge_base
    query("git branch --remotes --no-merged #{MAINLINE}").split("\n").map(&:strip)
  end

  def merge_base
    query("git merge-base #{MAINLINE} #{branch}")
  end
end

service = MergeRacer.new("HEAD")
# Signal.trap("TERM") { service.abort and exit }
service.call
